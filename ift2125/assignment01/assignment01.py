#!/usr/bin/env python
"""
@authors joseph d viviano and marzi mehdizad
"""
from exemplaires import *
import itertools
from copy import copy
import sys


def product(p, q):
    # p, q : 2 permutations (we suppose valid permutations)
    # Product (left to right) of permutations p*q
    return tuple([ q[p[i]-1] for i in range(len(p)) ])


def inverse(p):
    # p : permutation
    # Output : its inverse
    return tuple([ p.index(i)+1 for i in range(1, len(p)+1) ])


def sift(p, T):
    """
    p: permutation to sift
    T: table
    outputs permutation q if new permutation is inserted, otherwise None
    """
    m = len(p)
    IDENTITY = tuple(range(1, m+1))

    while p!= IDENTITY:

        # returns the min of the elements on p that are not in the location
        # of the permutation as they are in IDENTITY
        i = min(x for x in range(m) if p[x] != x+1)
        j = p[i]-1 # -1 for indexing purposes only

        if T[i][j] == IDENTITY:
            T[i][j] = p
            return(p)
        else:
            p = product(p, inverse(T[i][j]))

    return(None)


def assert_r_belongs(r, permutations):
    """
    Algorithm 6: does r belong to the group generated by the set permutations?
    """
    m = len(r)
    IDENTITY = tuple(range(1, m+1))
    # creates a mXm table T containing IDENTITY
    T = [[IDENTITY] * m for _ in range(m)]

    # pour assurer le tamisage des permutations en entrÃ©e
    to_sift = [(p) for p in permutations]

    # maintains set of table entries as a set
    entries = set()

    while len(to_sift) > 0:
        p = to_sift.pop()
        q = sift(p, T)

        if q is not None:
            entries.add(q)
            # the product q*q is considered since we added q to entries
            to_sift.extend([(product(q,p)) for p in entries])
            to_sift.extend([(product(p,q)) for p in entries])

    # returns none if no permutation is inserted (i.e., no fit is found)
    return(sift(r, T) is None)


def assert_permutation(p):
    """Raises an exception if p is not a valid permutation."""
    if len(p) != len(set(p)):
        raise(ValueError)


def n_multiply(permutations, product_list):
    """
    Generates product of permutations using the product_list in order.
    """
    new_perm = product(permutations[product_list[0]], permutations[product_list[1]])
    for i in range(2, len(product_list)):
        new_perm = product(new_perm, permutations[product_list[i]])

    return(new_perm)


def brute_force(k, p, permutations):
    """
    Runs the brute force algorithm for testing membership in permutation groups.
    """
    # takes care of when i=1 i.e., no products are taken
    S = set([permutations[0], permutations[1]])

    # test from the i=2...i=k case
    # use k+1 so I get the expected behaviour from range()
    for i in range(2, k+1):
        for product_list in itertools.product([0,1], repeat=i):
            new_perm = n_multiply(permutations, product_list)

            # NB: tuple must be wrapped in a set to behave properly when used
            # with union. Otherwise, union will add each element of the tuple
            # to the set individually (bad).
            S = S.union({new_perm})

        # check p against all permutations in S for each i (easy speed up).
        if p in S:
            return(True, i)

    # if we complete loop and do not find any matching permutation
    return(False, None)


def perm2(k, p, p1, p2, method='brute'):
    """Determines whether there is a permutation that maps p1*p2 to p"""
    try:
        assert_permutation(p)
    except ValueError:
        print('ERROR: input={} is not a valid permutation'.format(p))
        return(None)

    # use the brute force algorithm (default)
    if method == 'brute':
        result, i = brute_force(k, p, (p1, p2))
        if result:
            return(True)
        else:
            return(False)

    # use the intelligent method (sift)
    # NB: No way to tell how many k were required to solve, so the i/k part is
    # k/k for now. Should be fixed.
    elif method == 'smart':
        result = assert_r_belongs(p, (p1, p2))
        if result:
            return(True)
        else:
            return(False)

if __name__ == "__main__":
    if len(sys.argv) == 1:
        method = 'brute'
    elif len(sys.argv) == 2:
        method = sys.argv[1]

    if method not in ['brute', 'smart']:
        print('ERROR: method={} invalid, select from "brute" or "smart"')
    else:
        print('method={}'.format(method))

    perm2(k1, p1, p11, p21, method=method)
    perm2(k2, p2, p12, p22, method=method)
    perm2(k3, p3, p13, p23, method=method)
    perm2(k4, p4, p14, p24, method=method)
    perm2(k5, p5, p15, p25, method=method)
    perm2(k6, p6, p16, p26, method=method)
    perm2(k7, p7, p17, p27, method=method)

